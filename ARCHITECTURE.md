# Архитектура приложения WB API Integration

**Автор:** Yan Bubenok <yan@bubenok.com>

## Оглавление

1. [Общая архитектура](#общая-архитектура)
2. [Слои приложения](#слои-приложения)
3. [Паттерны проектирования](#паттерны-проектирования)
4. [Структура базы данных](#структура-базы-данных)
5. [Принятые решения](#принятые-решения)

## Общая архитектура

Приложение построено на основе чистой архитектуры с четким разделением ответственности между слоями:

```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│      (Console Commands, API)            │
└───────────────┬─────────────────────────┘
                │
┌───────────────▼─────────────────────────┐
│         Service Layer                   │
│  (Business Logic & Orchestration)       │
│  - ApiClientService                     │
│  - DataFetcherService                   │
│  - DataSyncService                      │
└───────────────┬─────────────────────────┘
                │
┌───────────────▼─────────────────────────┐
│         Repository Layer                │
│     (Data Access Abstraction)           │
│  - SaleRepository                       │
│  - OrderRepository                      │
│  - StockRepository                      │
│  - IncomeRepository                     │
└───────────────┬─────────────────────────┘
                │
┌───────────────▼─────────────────────────┐
│         Model Layer                     │
│      (Domain Entities)                  │
│  - Sale, Order, Stock, Income           │
└───────────────┬─────────────────────────┘
                │
┌───────────────▼─────────────────────────┐
│         Data Layer                      │
│      (Database, Cache)                  │
│  - MySQL, Redis                         │
└─────────────────────────────────────────┘
```

## Слои приложения

### 1. Presentation Layer (Слой представления)

**Ответственность:** Взаимодействие с пользователем/системой

**Компоненты:**
- `app/Console/Commands/SyncDataCommand.php` - Консольная команда для синхронизации

**Принципы:**
- Минимальная бизнес-логика
- Валидация входных данных
- Форматирование вывода
- Делегирование задач слою сервисов

### 2. Service Layer (Слой сервисов)

**Ответственность:** Бизнес-логика и оркестрация процессов

**Компоненты:**

#### ApiClientService
Низкоуровневый клиент для работы с API.

**Обязанности:**
- HTTP-запросы к WB API
- Аутентификация (добавление API ключа)
- Обработка пагинации
- Обработка ошибок HTTP
- Логирование запросов и ответов

**Ключевые методы:**
- `get(string $endpoint, array $params)` - Выполнить GET запрос
- `getPaginated()` - Получить данные с пагинацией
- `getAll()` - Получить все данные со всех страниц

#### DataFetcherService
Высокоуровневый сервис для получения бизнес-данных.

**Обязанности:**
- Получение данных конкретных типов (sales, orders, stocks, incomes)
- Формирование параметров запросов
- Преобразование дат в нужный формат

**Ключевые методы:**
- `fetchSales(Carbon $from, Carbon $to)` - Получить продажи
- `fetchOrders(Carbon $from, Carbon $to)` - Получить заказы
- `fetchStocks(Carbon $date)` - Получить остатки
- `fetchIncomes(Carbon $from, Carbon $to)` - Получить поступления
- `fetchAll()` - Получить все типы данных

#### DataSyncService
Сервис синхронизации данных с базой.

**Обязанности:**
- Сохранение данных из API в БД
- Обновление существующих записей
- Создание логов синхронизации
- Обработка ошибок сохранения
- Подсчет статистики (создано/обновлено/ошибок)

**Ключевые методы:**
- `syncSales()` - Синхронизировать продажи
- `syncOrders()` - Синхронизировать заказы
- `syncStocks()` - Синхронизировать остатки
- `syncIncomes()` - Синхронизировать поступления
- `syncAll()` - Синхронизировать все

### 3. Repository Layer (Слой репозиториев)

**Ответственность:** Абстракция доступа к данным

**Компоненты:**
- `BaseRepository` - Базовый класс с общей логикой
- `SaleRepository`, `OrderRepository`, `StockRepository`, `IncomeRepository` - Специфичные репозитории

**Преимущества паттерна Repository:**
- Изоляция бизнес-логики от деталей хранения
- Упрощение тестирования (легко мокировать)
- Единая точка для запросов к данным
- Возможность смены источника данных без изменения бизнес-логики

**Базовые методы:**
- `all()` - Получить все записи
- `find(int $id)` - Найти по ID
- `create(array $data)` - Создать запись
- `update(int $id, array $data)` - Обновить запись
- `delete(int $id)` - Удалить запись
- `findByExternalId(string $id)` - Найти по внешнему ID
- `updateOrCreateByExternalId()` - Создать или обновить

### 4. Model Layer (Слой моделей)

**Ответственность:** Представление доменных сущностей

**Модели:**
- `Sale` - Продажа
- `Order` - Заказ
- `Stock` - Остаток
- `Income` - Поступление
- `SyncLog` - Лог синхронизации

**Особенности:**
- Использование типизации PHP 8.2+
- Soft Deletes для всех основных моделей
- Кастинг типов данных (dates, decimals, json)
- Вспомогательные методы (findByExternalId, existsByExternalId)
- PHPDoc аннотации свойств

## Паттерны проектирования

### 1. Repository Pattern

Изолирует логику доступа к данным от бизнес-логики.

**Реализация:**
```php
interface RepositoryInterface {
    public function all(): Collection;
    public function find(int $id): ?Model;
    public function create(array $data): Model;
    // ...
}

abstract class BaseRepository implements RepositoryInterface {
    protected Model $model;
    // Общая реализация
}

class SaleRepository extends BaseRepository {
    // Специфичные методы для продаж
}
```

**Преимущества:**
- Единая точка доступа к данным
- Легкость тестирования
- Возможность кэширования на уровне репозитория

### 2. Service Layer Pattern

Инкапсулирует бизнес-логику в отдельных сервисах.

**Преимущества:**
- Разделение ответственности
- Переиспользуемость кода
- Упрощение тестирования

### 3. Dependency Injection

Все зависимости внедряются через конструктор.

**Пример:**
```php
class DataSyncService {
    public function __construct(
        DataFetcherService $dataFetcher,
        SaleRepository $saleRepository,
        // ...
    ) {
        // Laravel автоматически резолвит зависимости
    }
}
```

**Преимущества:**
- Слабая связанность компонентов
- Легкость замены реализаций
- Упрощение unit-тестирования

### 4. Single Responsibility Principle (SRP)

Каждый класс имеет одну ответственность:
- ApiClientService - только HTTP-запросы
- DataFetcherService - только получение данных
- DataSyncService - только синхронизация
- Repositories - только доступ к данным

### 5. Open/Closed Principle

Классы открыты для расширения, но закрыты для модификации:
- BaseRepository можно расширять, не изменяя его код
- Новые типы данных добавляются через наследование

## Структура базы данных

### ER-диаграмма

```
┌─────────────────────┐
│      sales          │
├─────────────────────┤
│ id (PK)             │
│ external_id (UQ)    │
│ sale_date (IDX)     │
│ order_number (IDX)  │
│ article (IDX)       │
│ ...                 │
└─────────────────────┘

┌─────────────────────┐
│      orders         │
├─────────────────────┤
│ id (PK)             │
│ external_id (UQ)    │
│ order_date (IDX)    │
│ order_number (UQ)   │
│ article (IDX)       │
│ status (IDX)        │
│ ...                 │
└─────────────────────┘

┌─────────────────────┐
│      stocks         │
├─────────────────────┤
│ id (PK)             │
│ external_id (UQ)    │
│ stock_date (IDX)    │
│ article (IDX)       │
│ warehouse (IDX)     │
│ ...                 │
└─────────────────────┘

┌─────────────────────┐
│      incomes        │
├─────────────────────┤
│ id (PK)             │
│ external_id (UQ)    │
│ income_date (IDX)   │
│ article (IDX)       │
│ warehouse (IDX)     │
│ supply_number (IDX) │
│ ...                 │
└─────────────────────┘

┌─────────────────────┐
│    sync_logs        │
├─────────────────────┤
│ id (PK)             │
│ entity_type (IDX)   │
│ started_at (IDX)    │
│ status (IDX)        │
│ records_processed   │
│ records_created     │
│ records_updated     │
│ records_failed      │
│ error_details (JSON)│
└─────────────────────┘
```

### Индексация

**Стратегия индексации:**
1. Первичные ключи (PK) - автоматические
2. Внешние идентификаторы (external_id) - уникальные индексы для быстрого поиска
3. Даты - индексы для фильтрации по периодам
4. Артикулы - индексы для поиска по товарам
5. Составные индексы - для часто используемых комбинаций (дата + артикул)

**Оптимизация запросов:**
- Soft Deletes с индексом на deleted_at
- JSON поля для дополнительных данных (гибкость схемы)
- Decimal типы для финансовых данных (точность)

## Принятые решения

### 1. Выбор архитектуры

**Решение:** Многослойная архитектура с Repository Pattern

**Обоснование:**
- Четкое разделение ответственности
- Легкость тестирования
- Масштабируемость
- Соответствие Laravel best practices

### 2. Структура таблиц

**Решение:** Отдельные таблицы для каждого типа данных

**Обоснование:**
- Разные наборы полей для каждого типа
- Оптимизация запросов
- Упрощение индексации
- Избежание NULL-значений

**Альтернатива (отклонена):** Single Table Inheritance
- Сложность запросов
- Много NULL-значений
- Проблемы с индексами

### 3. Хранение additional_data

**Решение:** JSON поле для сохранения полного ответа API

**Обоснование:**
- Не потеряем данные при изменении API
- Гибкость для будущих расширений
- Возможность анализа дополнительных полей
- Минимальные изменения при обновлении API

### 4. Логирование синхронизации

**Решение:** Отдельная таблица sync_logs

**Обоснование:**
- Мониторинг процесса синхронизации
- Отладка проблем
- Статистика операций
- Аудит

### 5. Soft Deletes

**Решение:** Использование soft deletes для основных таблиц

**Обоснование:**
- Возможность восстановления данных
- Аудит удалений
- Соответствие best practices

### 6. Обработка дубликатов

**Решение:** updateOrCreate по external_id

**Обоснование:**
- Идемпотентность операций
- Возможность повторной синхронизации
- Обновление измененных данных
- Защита от дублирования

### 7. Кэширование

**Решение:** Redis для кэширования

**Обоснование:**
- Быстрый доступ к часто используемым данным
- Снижение нагрузки на БД
- Поддержка Laravel из коробки

### 8. Обработка ошибок

**Решение:** Try-catch с логированием и продолжением обработки

**Обоснование:**
- Одна ошибка не должна останавливать весь процесс
- Детальное логирование для отладки
- Подсчет неудачных операций
- Возможность повторной обработки

### 9. Пагинация

**Решение:** Обработка по страницам с лимитом 500

**Обоснование:**
- Снижение нагрузки на память
- Защита от timeout
- Соответствие ограничениям API

### 10. Docker

**Решение:** Docker Compose для локальной разработки

**Обоснование:**
- Изолированное окружение
- Легкость воспроизведения
- Простота настройки для новых разработчиков
- Соответствие production окружению

## Возможности для расширения

### 1. Очереди (Queues)

Для асинхронной обработки больших объемов данных:
```php
dispatch(new SyncSalesJob($dateFrom, $dateTo));
```

### 2. Кэширование запросов

Кэширование часто запрашиваемых данных:
```php
Cache::remember('stocks_today', 3600, function() {
    return Stock::where('stock_date', today())->get();
});
```

### 3. Events & Listeners

Для расширяемости и слабой связанности:
```php
event(new DataSynced($syncLog));
```

### 4. API Endpoints

Добавление REST API для доступа к данным:
```php
Route::get('/api/sales', [SalesController::class, 'index']);
```

### 5. Веб-интерфейс

Dashboard для мониторинга синхронизации и просмотра данных.

## Заключение

Архитектура приложения построена с учетом принципов SOLID, использует проверенные паттерны проектирования и следует best practices Laravel. Это обеспечивает:

- **Масштабируемость** - легко добавлять новые типы данных
- **Поддерживаемость** - четкая структура и разделение ответственности
- **Тестируемость** - возможность unit и интеграционного тестирования
- **Надежность** - обработка ошибок и логирование
- **Производительность** - оптимизация запросов и кэширование

---

Документ подготовлен: Yan Bubenok <yan@bubenok.com>
